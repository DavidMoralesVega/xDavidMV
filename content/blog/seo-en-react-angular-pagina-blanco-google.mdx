---
title: "El problema del SEO en React y Angular: Por qué tu web sale en blanco en Google"
description: "Explicación técnica del conflicto entre SPAs y motores de búsqueda. Soluciones con SSR (Next.js, Angular Universal) y SSG para proyectos donde el SEO importa."
date: "2025-12-10"
tags: ["Desarrollo Web", "SEO Técnico", "React", "Angular", "Next.js"]
categories: ["Desarrollo Web", "SEO Técnico"]
image: "/img/blog/article/problema-seo.webp"
imageAlt: "Problema de SEO en React y Angular: página en blanco en Google y soluciones con SSR y Next.js"
published: true
---

Has creado una *Single Page Application* (SPA) increíble con React o Angular. Es rápida, las transiciones son suaves y se siente como una app nativa. Pero cuando la lanzas, pasan las semanas y **Google no indexa tu contenido.**

Entras a ver qué pasa en Google Search Console y descubres que, para Googlebot, tu web es una página en blanco con un `<div id="root"></div>`. ¿Por qué?

## El conflicto: CSR (Client Side Rendering) vs. Arañas

Las webs tradicionales (PHP, WordPress, Rails) envían el HTML completo desde el servidor. La araña de Google llega, lee el texto en el HTML, indexa y se va feliz.

En una SPA moderna creada con `create-react-app` o `Angular CLI`, el servidor envía un HTML casi vacío:

```html
<!DOCTYPE html>
<html>
<head>
  <title>Mi App</title>
</head>
<body>
  <div id="root"></div>
  <script src="/bundle.js"></script>
</body>
</html>
```

Es el **navegador del usuario** el que descarga, lee y ejecuta ese JavaScript para "pintar" el contenido. Esto se llama **Client Side Rendering (CSR).**

### ¿Google puede ejecutar JavaScript?

Sí... pero con limitaciones críticas:

1. **Crawl Budget:** Google asigna un presupuesto de rastreo a cada sitio. Ejecutar JS consume 10x más recursos que leer HTML. Si tu web tarda 5 segundos en renderizar, Google puede decidir no esperar.

2. **Latencia de APIs:** Si tu contenido depende de una llamada a API (`fetch('/api/products')`), y esa API tarda 2 segundos, Googlebot ve un spinner de carga en lugar de tus productos.

3. **Errores silenciosos:** Si tu JS tiene un error (un import que falla, una variable undefined), Google simplemente ve una página en blanco y **no te avisa.**

## La Solución: SSR, SSG e ISR

Para proyectos donde el SEO importa, no podemos confiar solo en el navegador. Tenemos tres arquitecturas de renderizado:

### 1. Server Side Rendering (SSR)

El servidor ejecuta tu código React/Angular y envía el HTML completo al navegador. Herramientas: **Next.js**, **Angular Universal**, **Remix**.

```tsx
// Next.js - Ejemplo de SSR
export async function getServerSideProps(context) {
  const { params } = context
  const res = await fetch(`https://api.example.com/products/${params.id}`)

  if (!res.ok) {
    return { notFound: true }
  }

  const product = await res.json()

  return {
    props: { product }
  }
}

export default function ProductPage({ product }) {
  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
      <span>${product.price}</span>
    </div>
  )
}
```

**Ventajas:**
- Google ve HTML completo al instante
- Datos siempre actualizados (cada request es fresh)
- SEO perfecto

**Desventajas:**
- Mayor carga en el servidor (cada página se genera on-demand)
- Latencia inicial más alta que SSG

**Cuándo usarlo:** E-commerce, dashboards con contenido personalizado, apps con datos en tiempo real.

### 2. Static Site Generation (SSG)

Generas **todo el HTML en tiempo de build** (cuando haces `npm run build`). El resultado son archivos HTML estáticos que sirves desde un CDN.

```tsx
// Next.js - Ejemplo de SSG
export async function getStaticProps() {
  const posts = await getAllPostsFromCMS()

  return {
    props: { posts },
    revalidate: 3600 // ISR: regenera cada hora
  }
}

export async function getStaticPaths() {
  const posts = await getAllPostsFromCMS()

  return {
    paths: posts.map(post => ({
      params: { slug: post.slug }
    })),
    fallback: 'blocking' // Genera páginas nuevas on-demand
  }
}

export default function BlogPost({ post }) {
  return <article>{post.content}</article>
}
```

**Ventajas:**
- Velocidad extrema (HTML estático en CDN)
- Costos mínimos de servidor
- SEO perfecto

**Desventajas:**
- No sirve para contenido que cambia constantemente
- Rebuild completo si actualizas contenido

**Cuándo usarlo:** Blogs, portfolios, landing pages, documentación.

### 3. Incremental Static Regeneration (ISR)

Lo mejor de ambos mundos: páginas estáticas que se regeneran en background cuando cambia el contenido.

```tsx
export async function getStaticProps() {
  const products = await fetch('https://api.example.com/products')
    .then(res => res.json())

  return {
    props: { products },
    revalidate: 60 // Regenera máximo cada 60 segundos
  }
}
```

Con `revalidate: 60`, Next.js:
1. Sirve la versión estática (súper rápida)
2. En background, verifica si pasaron 60 segundos
3. Si pasaron, regenera la página con datos frescos
4. La próxima visita recibe la versión actualizada

**Cuándo usarlo:** E-commerce con inventario que no cambia cada segundo, noticias, sitios con contenido semi-dinámico.

## Frameworks modernos y sus enfoques

| Framework | Renderizado por defecto | Ventaja principal |
|-----------|------------------------|-------------------|
| **Next.js** | Híbrido (SSG/SSR/ISR) | Flexibilidad total, aprende una vez |
| **Remix** | SSR puro | Modelo mental simple, data fetching integrado |
| **Astro** | SSG con "Islands" | Cero JS por defecto, hidratación parcial |
| **SvelteKit** | Híbrido (SSG/SSR) | Bundle más pequeño, rendimiento extremo |
| **Nuxt** (Vue) | Híbrido (SSG/SSR/ISR) | Next.js para el ecosistema Vue |

### Astro y la Arquitectura de Islas

Astro tiene un enfoque radical: **envía cero JavaScript por defecto.** Solo los componentes que marquen explícitamente como interactivos se hidratan en el cliente.

```astro
---
// Astro Component - Solo HTML por defecto
import Counter from '../components/Counter.jsx'
---

<div>
  <h1>Mi Blog</h1>
  <p>Este contenido es HTML puro, sin JS</p>

  <!-- Este componente sí tiene JS -->
  <Counter client:visible />
</div>
```

`client:visible` le dice a Astro: "Solo carga el JS de este componente cuando sea visible en viewport". El resto de la página es HTML estático.

**Resultado:** Sitios con 90+ en Lighthouse por defecto.

## El problema del enrutamiento client-side

Incluso con SSR/SSG, si usas React Router o Angular Router en modo `BrowserRouter`, puedes tener problemas:

```tsx
// ❌ Problema: Google puede no descubrir estas rutas
<BrowserRouter>
  <Routes>
    <Route path="/productos" element={<Products />} />
    <Route path="/servicios" element={<Services />} />
  </Routes>
</BrowserRouter>
```

Google descubre páginas siguiendo enlaces (`<a href>`). Si tus rutas solo existen en JavaScript y no hay `<a>` tags reales, Google no las encuentra.

**Solución:** Genera un sitemap.xml con todas tus rutas (lo vemos en el siguiente artículo) y usa `<Link>` components que generan `<a>` tags reales.

## Structured Data: El SEO que no ves

No basta con que Google indexe tu contenido, necesitas **structured data** (JSON-LD) para aparecer en rich snippets.

```tsx
// components/ProductSchema.tsx
export function ProductSchema({ product }) {
  const schema = {
    "@context": "https://schema.org",
    "@type": "Product",
    "name": product.name,
    "image": product.image,
    "description": product.description,
    "offers": {
      "@type": "Offer",
      "price": product.price,
      "priceCurrency": "USD",
      "availability": "https://schema.org/InStock"
    }
  }

  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{ __html: JSON.stringify(schema) }}
    />
  )
}
```

Esto le dice a Google: "Esto es un producto con precio, disponibilidad, etc." y puede mostrarlo en resultados enriquecidos.

## Verificación en Google Search Console

Una vez que implementes SSR/SSG, verifica que Google puede ver tu contenido:

1. Abre [Google Search Console](https://search.google.com/search-console)
2. Ve a **URL Inspection**
3. Pega una URL de tu sitio
4. Haz clic en "Test Live URL"
5. Revisa la pestaña **"Rendered HTML"**

Si ves tu contenido completo ahí, Google puede indexarlo. Si ves solo `<div id="root"></div>`, tienes un problema de renderizado.

## Análisis Final: Matriz de decisión

| Tipo de Proyecto | Renderizado Recomendado | Herramienta |
|------------------|------------------------|-------------|
| Dashboard privado (login required) | CSR (SPA normal) | Vite + React Router |
| Blog / Portfolio | SSG | Next.js, Astro |
| E-commerce | SSR o ISR | Next.js, Remix |
| Landing page marketing | SSG | Astro, Next.js |
| Docs / Knowledge base | SSG | Astro, Docusaurus |
| App con datos en tiempo real | SSR + CSR híbrido | Next.js, SvelteKit |
| Sitio corporativo | SSG | Astro (mejor rendimiento) |

### Caso especial: Hybrid Rendering

Para apps complejas, puedes mezclar estrategias:

```tsx
// app/layout.tsx - Next.js App Router
export default function RootLayout({ children }) {
  return <html>{children}</html>
}

// app/page.tsx - SSG (landing page)
export default function Home() {
  return <LandingPage />
}

// app/blog/[slug]/page.tsx - SSG con ISR (blog)
export const revalidate = 3600
export async function generateStaticParams() {
  const posts = await getPosts()
  return posts.map(post => ({ slug: post.slug }))
}

// app/dashboard/page.tsx - CSR con autenticación (no SEO needed)
'use client'
export default function Dashboard() {
  const { data } = useSWR('/api/user-data')
  return <DashboardContent data={data} />
}
```

Cada ruta usa la estrategia óptima para su caso de uso.

## El error fatal: Migrar sin pensar en SEO

He visto empresas migrar de WordPress a React SPA y perder el 70% del tráfico orgánico en 3 meses. El error:

1. Contratan a un desarrollador frontend que no entiende SEO
2. Usan `create-react-app` porque "es más fácil"
3. Lanzan la nueva web sin verificar en Search Console
4. 2 meses después: "¿Por qué no tenemos visitas?"

**Proceso correcto:**

1. Audita el tráfico orgánico actual (Google Analytics)
2. Identifica las páginas con más tráfico SEO
3. Elige framework con SSR/SSG (Next.js, Remix, Astro)
4. Implementa redirects 301 si cambias URLs
5. Genera sitemap.xml con todas las rutas
6. Verifica en Search Console **antes** de lanzar
7. Monitorea tráfico post-lanzamiento semanalmente

> Como ingenieros, es nuestra responsabilidad no solo hacer que la web funcione, sino que la web **sea encontrada**.
>
> — David Morales Vega

## Conclusión

Si estás haciendo un panel de administración privado (dashboard que requiere login), una SPA pura con CSR está perfecta. El SEO no importa porque Google no va a indexar páginas detrás de autenticación.

Pero si estás haciendo un e-commerce, una landing page, un blog o cualquier sitio público donde el tráfico orgánico importa, y usas `create-react-app` o `Angular CLI` sin pre-renderizado, **estás cometiendo suicidio SEO.**

La buena noticia: las herramientas modernas (Next.js 14+, Remix, Astro) hacen que SSR/SSG sea casi tan fácil como CSR. Solo necesitas elegir la herramienta correcta desde el principio.

No sacrifiques el SEO por la comodidad. Tu tráfico orgánico (y tu cliente) te lo agradecerán.

### Recursos para profundizar

- [Next.js Rendering Strategies](https://nextjs.org/docs/app/building-your-application/rendering)
- [Web.dev: Rendering on the Web](https://web.dev/rendering-on-the-web/)
- [Google Search Central: JavaScript SEO](https://developers.google.com/search/docs/crawling-indexing/javascript)
- [Astro Islands Architecture](https://docs.astro.build/en/concepts/islands/)
